const BaseTrigger = require('./baseTrigger.js').BaseTrigger;
const _ = require('lodash');
const Moment = require('moment');
const request = require('request');

const util = require('util');

/*
Trigger that responds to certain messages with specified responses.
matches = array of strings - messages that trigger the response
responses = array of strings - the response will be a randomly selected string from this array
exact = boolean - if this is true, the message received must be an exact match, if it's false the message just must contain the match (both case-insensitive)
users = array of string - the steamIds of the users that can trigger a response, can be null or empty to match all users
source = string - where to respond? in 'group', 'pm', or nothing to respond wherever the command was sent (default)
inPrivate = bool - only respond privately (true)? or everywhere (default/false)
*/

var rlStatTrigger = function () {
    rlStatTrigger.super_.apply(this, arguments);
};

util.inherits(rlStatTrigger, BaseTrigger);

var type = "rlStatTrigger";
exports.triggerType = type;
exports.create = function (name, chatBot, options) {
    var trigger = new rlStatTrigger(type, name, chatBot, options);
    trigger.options.inPrivate = options.inPrivate || false;
    trigger.options.source = options.source || undefined;
    trigger.options.exact = options.exact || false;
    return trigger;
};

// Return true if a message was sent
rlStatTrigger.prototype._respondToFriendMessage = function (userId, message) {
    if (this.options.source === "group") {
        return false;
    }
    return this._respond(userId, message, userId);
}

// Return true if a message was sent
rlStatTrigger.prototype._respondToChatMessage = function (roomId, chatterId, message) {
    if (this.options.source === "pm") {
        return false;
    }
    return this._respond(roomId, message, chatterId);
}


rlStatTrigger.prototype._respond = function (toId, message, fromId) {
    var dest = toId;
    if (this.options.inPrivate) {
        dest = fromId;
    }
    message = message.split("Ë").join(":");
    if (!message) {
        return false;
    }
    if (message.indexOf("!rlstats") > -1 || message.indexOf("!s") > -1) {
        var response = this._pickResponse();

        if (this._checkMessage(message)) {
            var response = this._pickResponse();
            var self = this;
            var url = 'https://rocketleague.tracker.network/profile/steam/' + fromId;

            request(url, function (error, response, body) {
                var userId = fromId;
                var finalized = "\r \n Stats for " + fromId + " are:";
                var allJunk = body;
                var test_str = body;
                var start_pos = test_str.indexOf(' <table class="table table-striped">') + ' <table class="table table-striped">'.length;
                var end_pos = test_str.indexOf('</table>', start_pos);
                var rankedArea = test_str.substring(start_pos, end_pos);
                var tableRowsAsArray = rankedArea.split("<tr>");
                var rankedObject = self._pageToObject(tableRowsAsArray);
                
                var rankedString = self._rankedObjectToString(rankedObject);                
                var result = rankedString;
                if (message.indexOf("watch my score") < 0 && message.indexOf("watch") < 0 && message.indexOf("w") < 0) {
                
                    if (message.indexOf("1v1") > -1 || message.indexOf("1") > -1) {
                        result = "\r \n " + rankedObject["1v1"].name + " : " + rankedObject["1v1"].rank + " : " + rankedObject["1v1"].nextDiv;
                    }
                    if (message.indexOf("2v2") > -1 || message.indexOf("2") > -1) {
                        result = "\r \n " + rankedObject["2v2"].name + " : " + rankedObject["2v2"].rank + " : " + rankedObject["2v2"].nextDiv;
                    }
                    if (message.indexOf("3v3") > -1 || message.indexOf("3") > -1) {
                        result = "\r \n " + rankedObject["3v3"].name + " : " + rankedObject["3v3"].rank + " : " + rankedObject["3v3"].nextDiv;
                    }
                    if (message.indexOf("3v3 solo") > -1 || message.indexOf("3s") > -1) {
                        result = "\r \n " + rankedObject["3v3_solo"].name + " : " + rankedObject["3v3_solo"].rank + " : " + rankedObject["3v3_solo"].nextDiv;
                    }
                    if (message.indexOf("unranked") > -1 || message.indexOf("u") > -1) {
                        result = "\r \n " + rankedObject["unranked"].name + " : " + rankedObject["unranked"].rank + " : " + rankedObject["unranked"].nextDiv;
                    }        


                    self._sendMessageAfterDelay(toId, "Current rank is:");
                    self._sendMessageAfterDelay(toId, result);
                } else {
                    if (message.indexOf("stop") < 0) {
                        // listen function here
                        var rankedString = self._rankedObjectToString(rankedObject);
                        self._sendMessageAfterDelay(toId, "Current rank is:");
                        self._sendMessageAfterDelay(toId, rankedString);
                        self._sendMessageAfterDelay(toId, "Going to watch for changes from now on.");

                        // default watch model
                        var original  = rankedObject,
                            current   = rankedObject,
                            old       = rankedObject,
                            checklist = ["1v1", "2v2", "3v3", "3v3_solo", "unranked"];

                        self._checkInterval = setInterval(function () {
                            // check for changes every 5 seconds
                            // new code, with request.
                            request(url, function (error, response, body) {
                                var userId = fromId;
                                var finalized = "\r \n Stats for " + fromId + " are:";
                                var allJunk = body;
                                var test_str = body;
                                var start_pos = test_str.indexOf(' <table class="table table-striped">') + ' <table class="table table-striped">'.length;
                                var end_pos = test_str.indexOf('</table>', start_pos);
                                var rankedArea = test_str.substring(start_pos, end_pos);
                                var tableRowsAsArray = rankedArea.split("<tr>");

                                current = self._pageToObject(tableRowsAsArray);

                                checklist.forEach(function (playlistName) {
                                    var playlistCurrent = current[playlistName],
                                        playlistOld     = old[playlistName];

                                    if (playlistCurrent.rank != playlistOld.rank) {
                                        console.log("### changes in playlist", playlistCurrent.name);
                                        self._sendMessageAfterDelay(toId, "Rank " + playlistName + " = " + playlistCurrent.rank + " ~ " + playlistCurrent.nextDiv);
                                    } else {
                                        console.log("No changes");
                                    }
                                });

                                old = current;
                            });
                        }, 30000);
                    } else {
                        if (!self._checkInterval) {
                            return false;
                        }
                        
                        self._sendMessageAfterDelay(toId, "Stopped watching.");
                        clearInterval(self._checkInterval);
                    }
                }
            });
            return true;
        }
        return false;
    }
    return false;
}

// Check for any text match
rlStatTrigger.prototype._checkMessage = function (message) {
    if (!this.options.matches || this.options.matches.length === 0) {
        return true; // match-all
    }

    for (var i = 0; i < this.options.matches.length; i++) {
        var match = this.options.matches[i];
        if ((this.options.exact && message.toLowerCase() === match.toLowerCase()) ||
            (!this.options.exact && message.toLowerCase().indexOf(match.toLowerCase()) >= 0)) {

            return true;
        }
    }

    return false;
}

rlStatTrigger.prototype._pickResponse = function (message) {
    if (this.options.responses && this.options.responses.length > 0) {
        var index = Math.floor(Math.random() * this.options.responses.length);
        return this.options.responses[index];
    }
    return "";
}

rlStatTrigger.prototype._rankedObjectToString = function (rankedObject) {
    var result = "";
    result += "\r \n " +      rankedObject["1v1"].name + " : " +      rankedObject["1v1"].rank + " : " +      rankedObject["1v1"].nextDiv;
    result += "\r \n " +      rankedObject["2v2"].name + " : " +      rankedObject["2v2"].rank + " : " +      rankedObject["2v2"].nextDiv;
    result += "\r \n " +      rankedObject["3v3"].name + " : " +      rankedObject["3v3"].rank + " : " +      rankedObject["3v3"].nextDiv;
    result += "\r \n " + rankedObject["3v3_solo"].name + " : " + rankedObject["3v3_solo"].rank + " : " + rankedObject["3v3_solo"].nextDiv;
    result += "\r \n " + rankedObject["unranked"].name + " : " + rankedObject["unranked"].rank + " : " + rankedObject["unranked"].nextDiv;
    
    return result;
}

rlStatTrigger.prototype._pageToObject = function (tableRowsAsArray) {
    var rankedObject = {};
    tableRowsAsArray.forEach(function (row) {
        var regex = /(<([^>]+)>)/ig;
        var rowCells = row.split("<td");
        // get playlist
        // get rank number without junk.
        rowCells.forEach(function (content, n) {
            rowCells[n] = rowCells[n].replace(/style="text-align:center;">/g, '');
            rowCells[n] = rowCells[n].replace(/style="width:32px;">/g, '');
            rowCells[n] = rowCells[n].replace(regex, '');
            rowCells[n] = rowCells[n].replace(/\s\s\s\s/g, '');
        });                    

        // making an object out of that gibberish.
        if (rowCells[2] != undefined) {
            if (rowCells[2].indexOf("3v3") > -1) {
                if (rowCells[2].indexOf("Solo") > -1) {
                    rankedObject["3v3_solo"] = {
                        rank: rowCells[4],
                        nextDiv: rowCells[5],
                        name: rowCells[2]
                    }
                } else {
                    rankedObject["3v3"] = {
                        rank: rowCells[4],
                        nextDiv: rowCells[5],
                        name: rowCells[2]
                    }                                     
                }
            }
            if (rowCells[2].indexOf("2v2") > -1) {
                rankedObject["2v2"] = {
                    rank: rowCells[4],
                    nextDiv: rowCells[5],
                    name: rowCells[2]
                }
            }
            if (rowCells[2].indexOf("1v1") > -1) {
                rankedObject["1v1"] = {
                    rank: rowCells[4],
                    nextDiv: rowCells[5],
                    name: rowCells[2]
                }                                
            }
            if (rowCells[2].indexOf("Un-Ranked") > -1) {
                rankedObject["unranked"] = {
                    rank: rowCells[4],
                    nextDiv: rowCells[5],
                    name: rowCells[2]
                }
            }
        }
        
    });
    return rankedObject;
    
}
